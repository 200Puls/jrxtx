
project.ext {

  cfgJavaVersion = '1.5'

  cfgVersion = '0.0.2-SNAPSHOT'
  
  cfgGroup = 'org.openmuc'

  cfgCopyDependencies = false

  cfgCopyToRoot = false

  cfgSignPom = true

  cfgRepository = project.properties.sonatypeRepository

  cfgSnapshotRepository = project.properties.sonatypeSnapshotRepository

  cfgRepositoryUser = project.properties.sonatypeUser

  cfgRepositoryPass = project.properties.sonatypePass

  javaProjects = allprojects

  distributionProjects = javaProjects

  docProjects = javaProjects

  repositoryProjects = javaProjects
}

tasks.withType(Tar) {

  into(project.name) {
    from('./') {
      include 'build.gradle'
      include 'configuration.gradle'
      include 'license/**'
      include 'doc/CHANGELOG.txt'
      include 'gradle/wrapper/**'
      include 'gradlew'
      include 'gradlew.bat'
      include 'build/libs/**'
      include 'src/**'
      include 'native/**'
      include 'README.adoc'
    }
  }

  into(project.name + "/doc/") {
    from("./build/docs/") {
      include "javadoc/**"
    }
  }

}

//------------------project specific configurations--------------------

apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'osgi'
apply plugin: 'maven'
apply plugin: 'signing'


jar {
  manifest {
    name = 'jRxTx'
    instruction 'Export-Package', '!*.internal.*,*'
  }
}

eclipse {
	jdt {
		javaRuntimeName = 'J2SE-1.5'
	}
}

javadoc {
  exclude "**/gnu/**"
}

uploadArchives {
  repositories {
    mavenDeployer {
      pom.project {
        name 'jRxTx'
        description 'jRxTx is a library for Java serial communication.'
        
        licenses {
          license {
            name 'GNU Lesser General Public License 2.1 or later + linking exception'
            url 'http://www.gnu.org/licenses/lgpl-2.1.html'
            distribution 'repo'
          }
        }
      }
    }
  }
}

jar {
  manifest { // the manifest of the default jar is of type OsgiManifest
    instruction 'Import-Package', '!gnu.io.internal.*, *'
  }
}

dependencies {
  testCompile 'org.mockito:mockito-core:1.10.19'
  testCompile 'org.powermock:powermock-api-mockito:1.6.4' 
  testCompile 'org.powermock:powermock-module-junit4:1.6.2' 

}

sourceSets {
	main {
		java.srcDirs = ['src/main-rxtx/java', 'src/main/java']
	}
}

task copyNativeLibs(type: Copy, dependsOn: compileJava) {
  
  println "test: " +  project.sourceSets.main.output.resourcesDir
  
  from fileTree('native').files
  def libName = 'librxtxSerial';
  
  include libName + '.so'
  include libName + '.dll'
  def resDir = project.sourceSets.main.output.resourcesDir
  
  into resDir.absolutePath + '/libs'
}



task compileNative(type:Exec) {
  workingDir 'native'

  def args = project.hasProperty('libTarget') ? project.property('libTarget') : ''
  
  //on linux
  commandLine './configure ' + args
  commandLine 'make'
  commandLine 'make'
  
  //store the output instead of printing to the console:
  standardOutput = new ByteArrayOutputStream()

  //extension method stopTomcat.output() can be used to obtain the output:
  ext.output = {
    return standardOutput.toString()
  }
}

task(buildNative) {
  dependsOn(compileNative)
  dependsOn(copyNativeLibs)
}



clean {
  file('native').listFiles().each{
  	File f ->  
  		if (f.getName().contains('unknown')) {
  			delete f
  		}
  	}
  
}
compileJava {
	options.encoding = 'UTF-8'
    options.compilerArgs << "-Xlint:unchecked"
}



task javah(dependsOn: compileJava) {
  doLast{
	  def Nclasses = [	
	    'gnu.io.RXTXCommDriver',
	    'gnu.io.CommPortIdentifier',
	    'gnu.io.RXTXVersion',
	    'gnu.io.I2C',
	    'gnu.io.LPRPort',
	    'gnu.io.RXTXPort',
	    'gnu.io.Zystem',
	    'gnu.io.Raw',
	    'gnu.io.RS485',
	    'gnu.io.ParallelPort'
	  ];
	    
	  def nativeIncludes = 'native/src/include'
	  def classpath = sourceSets.main.output.classesDir
	  for (Nclass in Nclasses) {
	      
	    logger.info('Generating header for ' + Nclass)
	      
	    exec {
		  executable 'javah'
		  args '-d', '$nativeIncludes', '-classpath', '$classpath' , Nclass
	    }
	  }
  }
}


sourceSets {
  itest {
    compileClasspath += sourceSets.main.compileClasspath
    runtimeClasspath += sourceSets.main.runtimeClasspath
  }
}

task itest(type: Test){
  systemProperty "java.library.path", "/usr/lib/jni/"
  testClassesDir = sourceSets.itest.output.classesDir
  classpath = sourceSets.itest.runtimeClasspath
}

